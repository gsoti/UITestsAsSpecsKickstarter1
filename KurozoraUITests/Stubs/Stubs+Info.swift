//
//  Stubs+Info.swift
//  KurozoraUITests
//
//  Created by Georgios Sotiropoulos on 11/9/24.
//  Copyright Â© 2024 Kurozora. All rights reserved.
//

import SBTUITestTunnelClient

fileprivate let path = "v1/info"

extension SBTStubResponse {
    // GUIDELINE: Use functions to control and reuse the JSON response for each
    // endpoint. Use as function arguments the properties that you would like to
    // control always having a deflaut value that is the normal case scenario
    static func info(isMaintenanceModeEnabled: Bool = false) -> SBTStubResponse {
        let body = """
        {
          "meta": {
            "version": "1.9.0",
            "minimumAppVersion": "1.9.0",
            "isMaintenanceModeEnabled": \(isMaintenanceModeEnabled),
            "isUserAuthenticated": false,
            "authenticatedUserID": "0"
          }
        }
        """
        return SBTStubResponse(body: body)
    }
    
    // GUIDELINE: Ideally you would like to use the same JSON used for mocking UI
    // tests testing the parsing into your own models in the target app so that
    // your mocks will be updated along with the app itself when a response model
    // has any changes.
    //
    // A better alternative, when possible, is that your app target and UI test target
    // share the response models themselves and the mocks should be generated by
    // serializing the response model to JSON. So in this case you would use the Meta
    // model found in the main target
}

extension StubCommand {
    static func info(isMaintenanceModeEnabled: Bool = false) -> StubCommand {
        return .init(
            requestMatch: SBTRequestMatch(url: path),
            response: .info(
                isMaintenanceModeEnabled: isMaintenanceModeEnabled
            )
        )
    }
}

extension StubCommand.Error {
    static func info() -> StubCommand {
        return .init(
            requestMatch: SBTRequestMatch(url: path),
            response: .apiErrorWith(body: "{}", statusCode: 400)
        )
    }
}
